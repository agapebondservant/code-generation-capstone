## 4.5 Restricting Access to Web Pages

Figure 4-3 Since the Windows version of Internet Explorer 5.0 supports gzip, this page was sent gzipped over the network and reconstituted by the browser, resulting in a large saving in download time.

<!-- image -->

## 4.5 Restricting Access to Web Pages

Many Web servers support standard mechanisms for limiting access to designated  Web  pages.  These  mechanisms  can  apply  to  static  pages  as  well  as those generated by servlets, so many authors use their server-specific mechanisms  for  restricting  access  to  servlets.  Furthermore,  most  users  at  e-commerce  sites  prefer  to  use  regular  HTML  forms  to  provide  authorization information since these forms are more familiar, can provide more explanatory information, and can ask for additional information beyond just a username and password. Once a servlet that uses form-based access grants initial access to a user, it would use session tracking to give the user access to other pages that require the same level of authorization. See Chapter 9 (Session Tracking) for more information.

Nevertheless, form-based access control requires more effort on the part of the servlet developer, and HTTP-based authorization is sufficient for many simple applications. Here's a summary of the steps involved for 'basic' authorization. There is also a slightly better variation called 'digest' authorization, but among the major browsers, only Internet Explorer supports it.

Home page for this book: www.coreservlets.com; Home page for sequel: www.moreservlets.com. Servlet and JSP training courses by book's author: courses.coreservlets.com.

## Chapter 4 Handling the Client Request: HTTP Request Headers

- 1. Check whether there is an Authorization header. If there is no such header, go to Step 2. If there is, skip over the word 'basic' and reverse the base64 encoding of the remaining part. This results in a string of the form username:password . Check the username and password against some stored set. If it matches, return the page. If not, go to Step 2.
- 2. Return a 401 ( Unauthorized ) response code and a header of the following form: WWW-Authenticate: BASIC realm="some-name" This response instructs the browser to pop up a dialog box telling the user to enter a name and password for some-name , then to reconnect with that username and password embedded in a single base64 string inside the Authorization header.

If you care about the details, base64 encoding is explained in RFC 1521 (remember,  to  retrieve  RFCs,  start  at http://www.rfc-editor.org/ to get a  current list  of  the  RFC  archive  sites).  However,  there  are  probably only two things you need to know about it. First, it is not intended to provide security, as the encoding can be easily reversed. So, it does not obviate the need for SSL to thwart attackers who might be able to snoop on your network  connection  (no  easy  task  unless  they  are  on  your  local  subnet). SSL,  or  Secure  Sockets  Layer,  is  a  variation  of  HTTP  where  the  entire stream  is  encrypted.  It  is  supported  by  many  commercial  servers  and  is generally invoked by using https in the URL instead of http . Servlets can run on SSL servers just as easily as on standard servers, and the encryption and  decryption  is  handled  transparently  before  the  servlets  are  invoked. The second point you should know about base64 encoding is that Sun provides the sun.misc.BASE64Decoder class,  distributed  with  both  JDK  1.1 and 1.2,  to  decode strings  that were  encoded with base64. Just be  aware that  classes  in  the sun package  hierarchy  are  not  part  of  the  official  language specification, and thus are not guaranteed to appear in all implemen-

## 4.5 Restricting Access to Web Pages

tations.  So,  if  you  use  this  decoder  class,  make  sure  that  you  explicitly include the class file when you distribute your application.

Listing 4.3 presents a password-protected servlet. It is explicitly registered with the Web server under the name SecretServlet . The process for registering  servlets  varies  from  server  to  server,  but  Section  2.7  (An  Example Using Initialization Parameters) gives details on the process for Tomcat, the JSWDK and the Java Web Server. The reason the servlet is registered is so that  initialization  parameters  can  be  associated  with  it,  since  most  servers don't let you set initialization parameters for servlets that are available merely by virtue of being in the servlets (or  equivalent) directory. The initialization parameter gives the location of a Java Properties file that stores user names and passwords. If the security of the page was very important, you'd want to encrypt the passwords so that access to the Properties file  would not equate to knowledge of the passwords.

In addition to reading the incoming Authorization header,  the  servlet specifies  a  status  code  of  401  and  sets  the  outgoing WWW-Authenticate header.  Status  codes  are  discussed  in  detail  in  Chapter  6  (Generating  the Server Response: HTTP Status Codes), but for now, just note that they convey high-level information to the browser and generally need to be set whenever  the  response  is  something  other  than  the  document  requested.  The most common way to set status codes is through the use of the setStatus method  of HttpServletResponse ,  and  you  typically  supply  a  constant instead of an explicit integer in order to make your code clearer and to prevent typographic errors.

WWW-Authenticate and  other  HTTP response  headers  are discussed in Chapter 7 (Generating the Server Response: HTTP Response Headers), but for now note that they convey auxiliary information to support the response specified by the status code, and they are commonly set through use of the setHeader method of HttpServletResponse .

Figures 4-4, 4-5, and 4-6 show the result when a user first tries to access the  page,  after  the  user  enters  an  unknown  password,  and  after  the  user enters a known password. Listing 4.4 gives the program that built the simple password file.

## 110

## Chapter 4 Handling the Client Request: HTTP Request Headers

```
Listing 4.3 ProtectedPage.java package coreservlets; import java.io.*; import javax.servlet.*; import javax.servlet.http.*; import java.util.Properties; import sun.misc.BASE64Decoder; /** Example of password-protected pages handled directly *  by servlets. */ public class ProtectedPage extends HttpServlet { private Properties passwords; private String passwordFile; /** Read the password file from the location specified *  by the passwordFile initialization parameter. */ public void init(ServletConfig config) throws ServletException { super.init(config); try { passwordFile = config.getInitParameter("passwordFile"); passwords = new Properties(); passwords.load(new FileInputStream(passwordFile)); } catch(IOException ioe) {} } public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType("text/html"); PrintWriter out = response.getWriter(); String authorization = request.getHeader("Authorization"); if (authorization == null) { askForPassword(response); } else { String userInfo = authorization.substring(6).trim();
```

## 4.5 Restricting Access to Web Pages

## Listing 4.3 ProtectedPage.java (continued)

```
BASE64Decoder decoder = new BASE64Decoder(); String nameAndPassword = new String(decoder.decodeBuffer(userInfo)); int index = nameAndPassword.indexOf(":"); String user = nameAndPassword.substring(0, index); String password = nameAndPassword.substring(index+1); String realPassword = passwords.getProperty(user); if ((realPassword != null) && (realPassword.equals(password))) { String title = "Welcome to the Protected Page"; out.println(ServletUtilities.headWithTitle(title) + "<BODY BGCOLOR=\"#FDF5E6\">\n" + "<H1 ALIGN=CENTER>" + title + "</H1>\n" + "Congratulations. You have accessed a\n" + "highly proprietary company document.\n" + "Shred or eat all hardcopies before\n" + "going to bed tonight.\n" + "</BODY></HTML>"); } else { askForPassword(response); } } } // If no Authorization header was supplied in the request. private void askForPassword(HttpServletResponse response) { response.setStatus(response.SC_UNAUTHORIZED); // Ie 401 response.setHeader("WWW-Authenticate", "BASIC realm=\"privileged-few\""); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }
```

<!-- image -->

<!-- image -->

## Chapter 4 Handling the Client Request: HTTP Request Headers

<!-- image -->

Figure 4-4 Initial result when accessing SecretServlet (the registered name for the ProtectedPage servlet).

Figure 4-5 Result after entering incorrect name or password.

<!-- image -->

Figure 4-6 Result after entering known name and password.

<!-- image -->

## 4.5 Restricting Access to Web Pages

```
Listing 4.4 PasswordBuilder.java import java.util.*; import java.io.*; /** Application that writes a simple Java properties file *  containing usernames and associated passwords. */ public class PasswordBuilder { public static void main(String[] args) throws Exception { Properties passwords = new Properties(); passwords.put("marty", "martypw"); passwords.put("bj", "bjpw"); passwords.put("lindsay", "lindsaypw"); passwords.put("nathan", "nathanpw"); // This location should *not* be Web-accessible. String passwordFile = "C:\\JavaWebServer2.0\\data\\passwords.properties"; FileOutputStream out = new FileOutputStream(passwordFile); // Using JDK 1.1 for portability among all servlet // engines. In JDK 1.2, use "store" instead of "save" // to avoid deprecation warnings. passwords.save(out, "Passwords"); } }
```

<!-- image -->